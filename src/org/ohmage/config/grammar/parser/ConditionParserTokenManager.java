/* Generated By:JavaCC: Do not edit this line. ConditionParserTokenManager.java */
package org.ohmage.config.grammar.parser;

/** Token Manager. */
public class ConditionParserTokenManager implements ConditionParserConstants
{
	/** 
	 * Debug output. 
	 */
	public static  java.io.PrintStream debugStream = System.out;
	/** 
	 * Set debug output. 
	 */
	public static  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
	
	private static final int jjStopStringLiteralDfa_0(int pos, long active0)
	{
		switch (pos)
		{
		case 0:
			if ((active0 & 0x600L) != 0L)
			{
				jjmatchedKind = 15;
				return 0;
			}
			return -1;
		case 1:
			if ((active0 & 0x400L) != 0L)
				return 0;
			if ((active0 & 0x200L) != 0L)
			{
				jjmatchedKind = 15;
				jjmatchedPos = 1;
				return 0;
			}
			return -1;
		default :
			return -1;
		}
	}
	
	private static final int jjStartNfa_0(int pos, long active0)
	{
		return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0), pos + 1);
	}
	
	static private int jjStopAtPos(int pos, int kind)
	{
		jjmatchedKind = kind;
		jjmatchedPos = pos;
		return pos + 1;
	}
	
	static private int jjMoveStringLiteralDfa0_0()
	{
		switch(curChar)
		{
		case 33:
			return jjMoveStringLiteralDfa1_0(0x10L);
		case 40:
			return jjStopAtPos(0, 1);
		case 41:
			return jjStopAtPos(0, 2);
		case 60:
			jjmatchedKind = 5;
			return jjMoveStringLiteralDfa1_0(0x80L);
		case 61:
			return jjMoveStringLiteralDfa1_0(0x8L);
		case 62:
			jjmatchedKind = 6;
			return jjMoveStringLiteralDfa1_0(0x100L);
		case 97:
			return jjMoveStringLiteralDfa1_0(0x200L);
		case 111:
			return jjMoveStringLiteralDfa1_0(0x400L);
		default :
			return jjMoveNfa_0(0, 0);
		}
	}
	
	static private int jjMoveStringLiteralDfa1_0(long active0)
	{
		try { curChar = SimpleCharStream.readChar(); }
		catch(java.io.IOException e) {
			jjStopStringLiteralDfa_0(0, active0);
			return 1;
		}
		switch(curChar)
		{
		case 61:
			if ((active0 & 0x8L) != 0L)
				return jjStopAtPos(1, 3);
			else if ((active0 & 0x10L) != 0L)
				return jjStopAtPos(1, 4);
			else if ((active0 & 0x80L) != 0L)
				return jjStopAtPos(1, 7);
			else if ((active0 & 0x100L) != 0L)
				return jjStopAtPos(1, 8);
			break;
		case 110:
			return jjMoveStringLiteralDfa2_0(active0, 0x200L);
		case 114:
			if ((active0 & 0x400L) != 0L)
				return jjStartNfaWithStates_0(1, 10, 0);
			break;
		default :
			break;
		}
		return jjStartNfa_0(0, active0);
	}
	
	static private int jjMoveStringLiteralDfa2_0(long old0, long active0)
	{
		if (((active0 &= old0)) == 0L)
			return jjStartNfa_0(0, old0);
		try { curChar = SimpleCharStream.readChar(); }
		catch(java.io.IOException e) {
			jjStopStringLiteralDfa_0(1, active0);
			return 2;
		}
		switch(curChar)
		{
		case 100:
			if ((active0 & 0x200L) != 0L)
				return jjStartNfaWithStates_0(2, 9, 0);
			break;
		default :
			break;
		}
		return jjStartNfa_0(1, active0);
	}
	
	static private int jjStartNfaWithStates_0(int pos, int kind, int state)
	{
		jjmatchedKind = kind;
		jjmatchedPos = pos;
		try { curChar = SimpleCharStream.readChar(); }
		catch(java.io.IOException e) { return pos + 1; }
		return jjMoveNfa_0(state, pos + 1);
	}
	
	static private int jjMoveNfa_0(int startState, int curPos)
	{
		int startsAt = 0;
		jjnewStateCnt = 1;
		int i = 1;
		jjstateSet[0] = startState;
		int kind = 0x7fffffff;
		for (;;)
		{
			if (++jjround == 0x7fffffff)
				ReInitRounds();
			if (curChar < 64)
			{
				long l = 1L << curChar;
				do
				{
					switch(jjstateSet[--i])
					{
					case 0:
						if ((0x3ff000000000000L & l) == 0L)
							break;
						kind = 15;
						jjstateSet[jjnewStateCnt++] = 0;
						break;
					default : break;
					}
				} while(i != startsAt);
			}
			else if (curChar < 128)
			{
				long l = 1L << (curChar & 077);
				do
				{
					switch(jjstateSet[--i])
					{
					case 0:
						if ((0x7fffffe87fffffeL & l) == 0L)
							break;
						kind = 15;
						jjstateSet[jjnewStateCnt++] = 0;
						break;
					default : break;
					}
				} while(i != startsAt);
			}
			else
			{
				do
				{
					switch(jjstateSet[--i])
					{
					default : break;
					}
				} while(i != startsAt);
			}
			if (kind != 0x7fffffff)
			{
				jjmatchedKind = kind;
				jjmatchedPos = curPos;
				kind = 0x7fffffff;
			}
			++curPos;
			if ((i = jjnewStateCnt) == (startsAt = 1 - (jjnewStateCnt = startsAt)))
				return curPos;
			try { curChar = SimpleCharStream.readChar(); }
			catch(java.io.IOException e) { return curPos; }
		}
	}
	
	static final int[] jjnextStates = {
	};

	/** 
	 * Token literal values. 
	 */
	public static final String[] jjstrLiteralImages = {
		"", "\50", "\51", "\75\75", "\41\75", "\74", "\76", "\74\75", "\76\75", 
		"\141\156\144", "\157\162", null, null, null, null, null, };

	/** 
	 * Lexer state names.
	 */
	public static final String[] lexStateNames = {
		"DEFAULT",
	};
	
	static final long[] jjtoToken = {
		0x87ffL, 
	};
	
	static final long[] jjtoSkip = {
		0x7800L, 
	};
	
	static protected SimpleCharStream input_stream;
	static private final int[] jjrounds = new int[1];
	static private final int[] jjstateSet = new int[2];
	static protected char curChar;
	
	/** 
	 * Constructor. 
	 */
	public ConditionParserTokenManager(SimpleCharStream stream){
		if (input_stream != null)
			throw new TokenMgrError("ERROR: Second call to constructor of static lexer. You must use ReInit() to initialize the static variables.", TokenMgrError.STATIC_LEXER_ERROR);
		input_stream = stream;
	}

	/** Constructor. */
	public ConditionParserTokenManager(SimpleCharStream stream, int lexState){
		this(stream);
		SwitchTo(lexState);
	}

	/** Reinitialise parser. */
	static public void ReInit(SimpleCharStream stream)
	{
		jjmatchedPos = jjnewStateCnt = 0;
		curLexState = defaultLexState;
		input_stream = stream;
		ReInitRounds();
	}
	static private void ReInitRounds()
	{
		int i;
		jjround = 0x80000001;
		for (i = 1; i-- > 0;)
			jjrounds[i] = 0x80000000;
	}

	/** Reinitialise parser. */
	static public void ReInit(SimpleCharStream stream, int lexState)
	{
		ReInit(stream);
		SwitchTo(lexState);
	}

	/** Switch to specified lex state. */
	static public void SwitchTo(int lexState)
	{
		if (lexState >= 1 || lexState < 0)
			throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);
		else
			curLexState = lexState;
	}

	static protected Token jjFillToken()
	{
		final Token t;
		final String curTokenImage;
		final int beginLine;
		final int endLine;
		final int beginColumn;
		final int endColumn;
		String im = jjstrLiteralImages[jjmatchedKind];
		curTokenImage = (im == null) ? SimpleCharStream.GetImage() : im;
		beginLine = SimpleCharStream.getBeginLine();
		beginColumn = SimpleCharStream.getBeginColumn();
		endLine = SimpleCharStream.getEndLine();
		endColumn = SimpleCharStream.getEndColumn();
		t = Token.newToken(jjmatchedKind, curTokenImage);

		t.beginLine = beginLine;
		t.endLine = endLine;
		t.beginColumn = beginColumn;
		t.endColumn = endColumn;

		return t;
	}

	static int curLexState = 0;
	static int defaultLexState = 0;
	static int jjnewStateCnt;
	static int jjround;
	static int jjmatchedPos;
	static int jjmatchedKind;

	/** Get the next Token. */
	public static Token getNextToken() 
	{
		Token matchedToken;
		int curPos = 0;

		EOFLoop :
			for (;;)
			{
				try
				{
					curChar = SimpleCharStream.BeginToken();
				}
				catch(java.io.IOException e)
				{
					jjmatchedKind = 0;
					matchedToken = jjFillToken();
					return matchedToken;
				}

				try { SimpleCharStream.backup(0);
				while (curChar <= 32 && (0x100002600L & (1L << curChar)) != 0L)
					curChar = SimpleCharStream.BeginToken();
				}
				catch (java.io.IOException e1) { continue EOFLoop; }
				jjmatchedKind = 0x7fffffff;
				jjmatchedPos = 0;
				curPos = jjMoveStringLiteralDfa0_0();
				if (jjmatchedKind != 0x7fffffff)
				{
					if (jjmatchedPos + 1 < curPos)
						SimpleCharStream.backup(curPos - jjmatchedPos - 1);
					if ((jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L)
					{
						matchedToken = jjFillToken();
						return matchedToken;
					}
					else
					{
						continue EOFLoop;
					}
				}
				int error_line = SimpleCharStream.getEndLine();
				int error_column = SimpleCharStream.getEndColumn();
				String error_after = null;
				boolean EOFSeen = false;
				try { SimpleCharStream.readChar(); SimpleCharStream.backup(1); }
				catch (java.io.IOException e1) {
					EOFSeen = true;
					error_after = curPos <= 1 ? "" : SimpleCharStream.GetImage();
					if (curChar == '\n' || curChar == '\r') {
						error_line++;
						error_column = 0;
					}
					else
						error_column++;
				}
				if (!EOFSeen) {
					SimpleCharStream.backup(1);
					error_after = curPos <= 1 ? "" : SimpleCharStream.GetImage();
				}
				throw new TokenMgrError(EOFSeen, curLexState, error_line, error_column, error_after, curChar, TokenMgrError.LEXICAL_ERROR);
			}
	}
}